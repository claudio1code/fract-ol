# üåÄ Fract-ol

![Fractol Demo](fractol_final.gif)

## üìñ Introduction

**Fract-ol** is a graphical exploration project developed in C. It renders mathematically generated fractals‚Äîgeometric shapes that exhibit self-similarity at different scales. This project uses the **MiniLibX** library to open a window and draw pixels directly to the screen based on complex mathematical formulas.

The goal is to understand the math behind fractals, manipulate the complex plane, and optimize pixel rendering algorithms.

## üìê Theoretical Background

### What is a Fractal?

A fractal is a never-ending pattern. They are infinitely complex patterns that are self-similar across different scales. Fract-ol focuses on the **Mandelbrot set** and the **Julia set**, which are generated by iterating a simple equation on the plane of complex numbers.

### The Math: `f(z) = z¬≤ + c`

The core of the project relies on this recursive formula:

$$ z_{n+1} = z_n^2 + c $$

Where:
- **$z$** and **$c$** are complex numbers (composed of a real part $x$ and an imaginary part $yi$).
- **$z$** represents the current state of the iteration.
- **$c$** is a constant parameter.

#### Mandelbrot Set
For the Mandelbrot set, we calculate the sequence starting from $z = 0$. We treat every point on the screen as a candidate for $c$. If the magnitude of $z$ remains bounded (doesn't escape to infinity) after a fixed number of iterations, that point $c$ belongs to the set (colored black). If it escapes, we color it based on how quickly it escaped.

#### Julia Set
For the Julia set, $c$ is a fixed constant chosen by the user (e.g., via command line arguments). We treat every point on the screen as a starting value for $z$. Changing the constant $c$ drastically changes the shape of the fractal, leading to infinite variations.

## üé® Rendering & Colors

### MiniLibX & Pixel Buffer
Rendering fractals requires calculating millions of pixels per second. Using standard drawing functions like `mlx_pixel_put` is too slow because it pushes pixels one by one to the X server.

Instead, this project utilizes **Direct Image Manipulation**:
1. We create an **Image Buffer** in memory using `mlx_new_image`.
2. We access the raw memory address of the pixel data via `mlx_get_data_addr`.
3. We calculate the color for every pixel and write the integer value (ARGB) directly into memory.
4. Finally, we push the entire image to the window at once using `mlx_put_image_to_window`.

This technique allows for real-time rendering and smooth zooming.

### Color Algorithms
To turn raw mathematical data into art, we use the **Escape Time Algorithm**. The color of a pixel is determined by the number of iterations ($i$) it took for $z$ to exceed a threshold radius (usually 2.0).

To achieve smooth, psychedelic transitions, we map the iteration count to RGB values using trigonometric functions (sine waves). This avoids hard bands of color and creates a fluid visual effect.

```c
// Example of Sine-based coloring logic
r = sin(frequency * i + phase_r) * 127 + 128;
g = sin(frequency * i + phase_g) * 127 + 128;
b = sin(frequency * i + phase_b) * 127 + 128;
```

## üõ†Ô∏è Usage

### Compilation
The project compiles a static executable using the Makefile. Ensure you have `make`, `gcc` and `X11` libraries installed.

```bash
make
```

### Running the Project

**1. Mandelbrot Set:**
```bash
./fractol mandelbrot
```

**2. Julia Set:**
You must provide the real and imaginary parts of the constant $c$.
```bash
./fractol julia -0.8 0.156
```
*Interesting values to try:*
*   `0.285 0.01`
*   `-0.7269 0.1889`
*   `-0.4 0.6`

## üéÆ Controls

| Input | Action |
| :--- | :--- |
| **Mouse Wheel** | Zoom In / Out (centered on cursor) |
| **Arrows** | Move the view (Pan) |
| **Numpad + / -** | Shift Color Frequency |
| **ESC / Close** | Quit program |

---
*Project developed for the 42 Curriculum.*